<?php

declare(strict_types=1);

namespace Loom\Config;

use Closure;
use Generator;
use Loom\Util\ArrayUtil;
use function class_exists;
use function date;
use function file_exists;
use function file_put_contents;
use function get_class;
use function gettype;
use function is_array;
use function is_callable;
use function is_object;
use function is_string;
use function sprintf;
use function var_export;

/**
 * Gather configuration generated by configuration providers.
 */
class ConfigGather
{
    const ENABLE_CACHE = 'config_cache_enabled';

    const CACHE_TEMPLATE = <<< 'EOT'
<?php
/**
 * This configuration cache file was generated by %s
 * at %s
 */
return %s;

EOT;

    /**
     * @var array
     */
    private $config;

    /**
     * @param array $providers Array of providers. These may be callables, or
     *     string values representing classes that act as providers. If the
     *     latter, they must be instantiable without constructor arguments.
     * @param null|string $cachedConfigFile Configuration cache file; config is
     *     loaded from this file if present, and written to it if not. null
     *     disables caching.
     * @param array $postProcessors Array of processors. These may be callables, or
     *     string values representing classes that act as processors. If the
     *     latter, they must be instantiable without constructor arguments.
     */
    public function __construct(array $providers = [], string $cachedConfigFile = null, array $postProcessors = [])
    {
        if ($this->loadConfigFromCache($cachedConfigFile)) {
            return;
        }

        $this->config = $this->loadConfigFromProviders($providers);
        $this->config = $this->postProcessConfig($postProcessors, $this->config);
        $this->cacheConfig($this->config, $cachedConfigFile);
    }

    /**
     * @return array
     */
    public function getMergedConfig(): array
    {
        return $this->config;
    }

    /**
     * Resolve a provider.
     *
     * If the provider is a string class name, instantiates that class and
     * tests if it is callable, returning it if true.
     *
     * If the provider is a callable, returns it verbatim.
     *
     * Raises an exception for any other condition.
     *
     * @param string|callable $provider
     * @return callable
     * @throws Exception\InvalidConfigProviderException
     */
    private function resolveProvider($provider): callable
    {
        if (is_string($provider)) {
            if (! class_exists($provider)) {
                throw Exception\InvalidConfigProviderException::fromNamedProvider($provider);
            }
            $provider = new $provider();
        }

        if (! is_callable($provider)) {
            $type = $this->detectVariableType($provider);
            throw Exception\InvalidConfigProviderException::fromUnsupportedType($type);
        }

        return $provider;
    }

    /**
     * Resolve a processor.
     *
     * If the processor is a string class name, instantiates that class and
     * tests if it is callable, returning it if true.
     *
     * If the processor is a callable, returns it verbatim.
     *
     * Raises an exception for any other condition.
     *
     * @param string|callable $processor
     * @return callable
     * @throws Exception\InvalidConfigProcessorException
     */
    private function resolveProcessor($processor): callable
    {
        if (is_string($processor)) {
            if (! class_exists($processor)) {
                throw Exception\InvalidConfigProcessorException::fromNamedProcessor($processor);
            }
            $processor = new $processor();
        }

        if (! is_callable($processor)) {
            $type = $this->detectVariableType($processor);
            throw Exception\InvalidConfigProcessorException::fromUnsupportedType($type);
        }

        return $processor;
    }

    /**
     * Merge configuration from a provider with existing configuration.
     *
     * @param array $mergedConfig Passed by reference as a performance/resource
     *     optimization.
     * @param mixed|array $config Configuration generated by the $provider.
     * @param callable $provider Provider responsible for generating $config;
     *     used for exception messages only.
     * @return void
     * @throws Exception\InvalidConfigProviderException
     */
    private function mergeConfig(&$mergedConfig, $config, callable $provider): void
    {
        if (! is_array($config)) {
            $type = $this->detectVariableType($provider);

            throw new Exception\InvalidConfigProviderException(sprintf(
                'Cannot read config from %s; does not return array',
                $type
            ));
        }

        $mergedConfig = ArrayUtil::mergeArray($mergedConfig, $config);
    }

    /**
     * Iterate providers, merging config from each with the previous.
     *
     * @param array $providers
     * @return array
     */
    private function loadConfigFromProviders(array $providers): array
    {
        $mergedConfig = [];
        foreach ($providers as $provider) {
            $provider = $this->resolveProvider($provider);
            $config = $provider();
            if (! $config instanceof Generator) {
                $this->mergeConfig($mergedConfig, $config, $provider);
                continue;
            }

            // Handle generators
            foreach ($config as $cfg) {
                $this->mergeConfig($mergedConfig, $cfg, $provider);
            }
        }
        return $mergedConfig;
    }

    /**
     * Attempt to load the configuration from a cache file.
     *
     * @param null|string $cachedConfigFile
     * @return bool
     */
    private function loadConfigFromCache(string $cachedConfigFile = null): bool
    {
        if (null === $cachedConfigFile) {
            return false;
        }

        if (! file_exists($cachedConfigFile)) {
            return false;
        }

        $this->config = require $cachedConfigFile;
        return true;
    }

    /**
     * Attempt to cache discovered configuration.
     *
     * @param array $config
     * @param null|string $cachedConfigFile
     */
    private function cacheConfig(array $config, string $cachedConfigFile = null)
    {
        if (null === $cachedConfigFile) {
            return;
        }

        if (empty($config[static::ENABLE_CACHE])) {
            return;
        }

        file_put_contents($cachedConfigFile, sprintf(
            self::CACHE_TEMPLATE,
            get_class($this),
            date('c'),
            var_export($config, true)
        ));
    }

    /**
     * @param array $processors
     * @param array $config
     * @return array
     */
    private function postProcessConfig(array $processors, array $config): array
    {
        foreach ($processors as $processor) {
            $processor = $this->resolveProcessor($processor);
            $config = $processor($config);
        }

        return $config;
    }

    /**
     * @param Closure|object|callable $variable
     *
     * @return string
     */
    private function detectVariableType($variable): string
    {
        if ($variable instanceof Closure) {
            return 'Closure';
        }

        if (is_object($variable)) {
            return get_class($variable);
        }

        if (is_callable($variable)) {
            return is_string($variable) ? $variable : gettype($variable);
        }

        return gettype($variable);
    }
}
